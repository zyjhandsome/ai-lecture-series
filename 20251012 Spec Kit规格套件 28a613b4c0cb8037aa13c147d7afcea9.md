# 20251012 Spec Kit规格套件

**Spec Kit：更快地构建高质量的软件。努力让组织能够专注于产品场景，而不是在规范驱动开发的帮助下编写无差别的代码。**

# 参考

- [github/spec-kit: 💫 Toolkit to help you get started with Spec-Driven Development](https://github.com/github/spec-kit)

# Spec Kit的核心优势

![image.png](20251012%20Spec%20Kit%E8%A7%84%E6%A0%BC%E5%A5%97%E4%BB%B6/image.png)

# Spec的使用

前提条件：确保已经安装UV。

```bash
pip install uv

```

![image.png](20251012%20Spec%20Kit%E8%A7%84%E6%A0%BC%E5%A5%97%E4%BB%B6/image%201.png)

# 核心命令

运行后`specify init`，您的 AI 编码代理将可以访问这些斜线命令以进行结构化开发：

**核心命令**

规范驱动开发工作流程的基本命令：

| **命令** | **描述** |
| --- | --- |
| `/speckit.constitution` | 创建或更新项目管理原则和开发指南 |
| `/speckit.specify` | 定义您想要构建的内容（需求和用户故事） |
| `/speckit.plan` | 使用您选择的技术堆栈创建技术实施计划 |
| `/speckit.tasks` | 生成可执行的任务列表以供实施 |
| `/speckit.implement` | 按照计划执行所有任务以构建功能 |

**可选命令**

用于增强质量和验证的附加命令：

| **命令** | **描述** |
| --- | --- |
| `/speckit.clarify` | 澄清未指定的区域（之前建议`/speckit.plan`；以前`/quizme`） |
| `/speckit.analyze` | 跨工件一致性和覆盖率分析（在之后`/speckit.tasks`、之前运行`/speckit.implement`） |
| `/speckit.checklist` | 生成自定义质量检查表，以验证需求的完整性、清晰度和一致性（例如“英语单元测试”） |

**样例**

```bash
> /constitution Keep the ios Forest-style focus app radically simple and
offline-first.
Enforce test-first development, 60fps animations, <2s cold start, and
VoiceOver/Dynamic Type support.

> /specify Build a Forest-style Pomodoro app for i0s: start a 25-minute
session to "plant"
a tree that grows through 5 stages; cancel/quit kills the tree; completion
saves it to a
personal forest. Show countdown, pause/resume, local notification, and
background-accurate timing.
Store completed/abandoned sessions locally; show a forest grid and stats
(total trees, total focus
time, today's count, daily streak). Out of scope: custom durations, species,
sync, sharing, watch, widgets.

> /plan Use SwiftUI SwiftData oni0S 17+. Timer via Combine; local
notifications via
UNUserNotificationCenter; smooth 60fps growth animations; no third-party
deps.
Use XCTest/XCUITest; keep memory <50MB during active sessions.

> /task

> /analyze

> /clear
建议执行清空上下文命令，前面产生的上下文对后面的执行已经没什么作用了。

在执行implement命令之前，建议先使用IDE（例如XCode），创建一个初始工程。
> /implement
```

# GitHub 的新工具 Spec Kit 完全颠覆你的想象：4 个将改变你 AI 编程方式的惊人见解

总结来自[The ONLY guide you'll need for GitHub Spec Kit - YouTube](https://www.youtube.com/watch?v=a9eR1xsfvHg)。

### 引言：告别“感觉式编程”的混乱

你是否曾有过这样的经历？满怀激情地用 AI 开启一个新项目，让模型生成一些初始代码，感觉一切顺利。但很快，你就发现自己陷入了一个又一个方向不明、结果不一致的“兔子洞”(random rabbit holes)。项目偏离了初衷，代码质量参差不齐，整个过程混乱不堪。这种在大型语言模型（LLM）的随机性中随波逐流的困境，被形象地称为“感觉式编程”(vibe coding)。

这不仅仅是个人开发者的烦恼，更是 AI 辅助开发走向成熟必须跨越的障碍。现在，GitHub 推出的新实验性工具 Spec Kit，正是为了解决这一核心问题而来。它不是又一个代码生成器，而是一套旨在将混乱的 AI 编程过程，转变为一种更具结构化、可扩展性的软件工程实践的方法论。

这篇文章将为你揭示 Spec Kit 中四个最令人惊讶、甚至有些违反直觉的核心理念。它们将展示 Spec Kit 如何从根本上改变我们与 AI 协作构建软件的方式，引领我们从“对话式编码”迈向真正的“规范驱动工程”。

### 1. 超越“感觉式编程”：分离“做什么”与“怎么做”的力量

Spec Kit 的核心哲学，是对当前 AI 编程混乱状态的一记重拳：它强制性地将项目的构想阶段（“做什么 What”和“为什么 Why”）与技术实现阶段（“怎么做 How”）彻底分离开来。这不仅是良好的软件工程实践，更是驾驭 LLM 创造力所必需的纪律。

这种分离是通过两个在独立 Git 分支上运行的关键步骤实现的，确保了实验过程不会污染你的主干代码：

- **`/specify` 命令**: 在这一步，你的角色是产品经理。你的任务是专注于定义产品需求、用户场景和项目动机，完全不涉及任何技术细节。此命令会创建一个新的 Git 分支，生成一份与实现无关的纯粹的规范（spec）文档。
- **`/plan` 命令**: 只有在规范被清晰定义并确立之后，你才开始进入技术规划阶段。在另一个专用分支上，你可以定义技术方案，例如决定使用 Next.js、配置静态网站等。

为什么这种分离如此革命性？因为它正是“感觉式编程”的解药。它通过强制的结构化流程，阻止开发者在项目初期就和 AI 一起陷入技术选型的细节泥潭，确保构建的东西从一开始就符合真正的用户需求。它首先确立了坚实的目标，然后才允许 AI 在限定的范围内发挥其生成能力。

“这里的规范之所以有价值，在于它与实现完全解耦。所以，即便你最初计划用 Next.js 构建，但未来某天想换成 Hugo 或任何其他静态网站生成器，你用的还是同一份规范。” (The benefit of the spec here is that it is completely detached from the implementation. So if at some point you know we're going to be building this with Nex.js but at some point you switch to Hugo or any other static side generator You use the same spec.)

### 2. 项目“宪法”：为你的 AI 队友设定不可逾越的规则

Spec Kit 引入了一个极为独特且强大的概念：`constitution.md` 文件。这不仅仅是一个配置文件，而是项目的一套“不可动摇的原则”或“非协商性原则”(non-negotiable principles)。它是你为 AI 代理设定的“法律”。

这份“宪法”文件用于程序化地强制执行项目的核心规则、架构约束和质量标准。例如，你可以明确规定：

- “项目必须始终包含测试。” (I always have to have tests)
- “必须使用特定版本的 Next.js。”
- “所有产出都必须面向 Cloudflare 或 Azure 部署。”

一旦设定，LLM 在后续的每一个步骤中（尤其是在 `/plan` 阶段）都必须参考并严格遵守这部“宪法”。正如 Spec Kit 的维护者所说，当规划开始时，“宪法在此生效”(the constitution is in play)。

这一点之所以强大，是因为它为与 AI 的协作提供了坚实的“护栏工程”(guardrail engineering)。它解决了 AI 最令人头疼的问题之一：倾向于“幻觉”或忽略非功能性需求。通过这部宪法，开发者可以编程方式确保 AI 的创造力不会偏离项目的核心架构和质量标准，从根本上解决了 AI 输出不稳定、不合规范的关键痛痛点。

### 3. 你的规范是可复用的蓝图，而非一次性配方

正是因为第一点中提到的“规范与实现的分离”，才催生了 Spec Kit 最具价值的特性之一：规范的彻底可复用性。

这意味着，你的 `spec.md` 文件是一份独立于任何技术的、可移植的项目蓝图。你可以拿着同一份规范，让 AI 使用完全不同的技术栈来重新实现整个项目。今天你可以让它用 Next.js 构建，明天就可以让它用 Hugo 或 SvelteKit 再实现一遍，而无需重写任何需求。

这一点的实际价值是巨大的。它极大地便利了技术选型、版本迭代和方案实验。你可以让不同的 AI 模型（例如 GPT-4o、Claude 3.5 Sonnet）基于同一份规范进行构建，然后比较它们的结果，从而找到最佳的实现方案。

“你本质上拥有了这份规范和所有产物。你可以随时删除全部源代码，因为规范本身还在，然后就能用一个完全不同的模型来重新构建项目。” (You essentially have the spec You have all your artifacts You can just delete the source The spec is still there and then use a different model.)

### 4. 这不是魔法，而是 Markdown：你依然是架构师

Spec Kit 看起来很神奇，但其底层机制却非常透明和务实，这恰恰是它最令人信服的地方。它并非一个神秘的黑箱，而是一套经过深思熟虑的工程系统。

所谓的“斜杠命令”（如 `/specify` 或 `/plan`）并非魔法。它们本质上是存储在项目 `.github` 文件夹中的自定义 Markdown 提示模板，这些模板会智能地调用两类工具：

1. **确定性脚本 (Shell/PowerShell)**: 对于需要精确和可靠的操作，如创建 Git 分支或生成文件结构，Spec Kit 会运行辅助脚本。因为这些任务不应交由 LLM 的随机性来处理。
2. **大型语言模型 (LLM)**: 对于需要创造力和理解力的任务，如根据你的意图撰写规范内容或技术计划，Spec Kit 才会调用 LLM。

更重要的是，所有由 Spec Kit 生成的产物——无论是规范、计划还是任务列表——都是简单的 Markdown 文件。这意味着它们是完全人类可读、可编辑的。开发者始终拥有最终的控制权。正如 Spec Kit 维护者 Den Delimarsky 所强调的，你应该主动介入：

“不，它就是一个 Markdown 文件。直接上手，开始输入和添加你认为产品所需要的要求。你不需要请求大语言模型来做这件事。” (No it's a markdown file Go in with your hands and start typing and entering requirements that you feel are you know required for your product. You don't need to ask the LM to do this.)

这一点至关重要。Spec Kit 并没有试图取代开发者，而是将开发者从繁琐的脚手架和样板代码中解放出来，*提升*到更高层次的角色：定义核心问题的系统架构师、设定架构规则的立法者，以及审查最终产出的总负责人。

### 结论：迎接与 AI 协作的新范式

总结来说，Spec Kit 带来的不仅仅是一个工具，更是一种与 AI 进行结构化、可预测和高质量协作的全新方法论。它通过环环相扣的理念，将软件开发带入一个新阶段：

通过 **分离“做什么”与“怎么做” (第一点)**，Spec Kit 创造了一份 **可复用的项目蓝图 (第三点)**。整个流程由一部 **项目“宪法” (第二点)** 来约束，以确保架构和质量的统一。而最关键的是，这一切都建立在 **透明、可控的 Markdown 文件和确定性脚本之上 (第四点)**，让开发者始终处于主导地位。

它将我们与 AI 的协作模式从“让 AI 随便写点代码”的即兴表演，提升到了“与 AI 共同进行软件工程”的专业实践。

当 AI 编程成为常态，这种结构化的规范驱动开发，是否就是我们从构建简单脚本迈向开发复杂、可靠的生产级软件所必需的关键一步？Spec Kit 给出了一个响亮而肯定的答案。

### 附录（原文摘要）

Dan Delamarski介绍了GitHub的新项目SpecKit，强调其在开发中的重要性和快速增长的用户反馈。SpecKit是一个工具包，旨在简化开发流程，特别是针对软件开发中的规范驱动开发。视频展示了如何使用SpecKit的CLI工具来启动项目，并通过示例演示了如何创建一个现代播客网站。Dan强调了项目中的“宪法”文件的重要性，以确保项目遵循非可谈判的原则。此外，他鼓励用户提供反馈，以帮助改进SpecKit并增强其功能。

亮点:
00:00 SpecKit是一个由GitHub推出的工具包，旨在简化Spectrum开发过程。它已经在发布一周内获得了超过16,000个星标，显示出开发者社区的积极参与和反馈。

- SpecKit旨在帮助开发者更轻松地进行Spectrum开发，避免在编码过程中出现的各种问题。它提供了一种更可扩展的解决方案，帮助开发者从模糊的编码思维中走出来。
- 该工具包包括Specify CLI，能够自动生成项目所需的基本架构。开发者可以通过GitHub直接获取，简化了项目的启动过程，无需复杂的安装步骤。
- SpecKit支持多种操作系统和脚本类型，开发者可以根据自己的需求选择合适的工具。无论是Linux还是Windows，都能找到适合的脚本，方便开发者使用。

06:05 在脚本选择中，选择合适的脚本对于项目的成功至关重要。使用确定性的脚本可以简化开发流程，确保项目的元数据和其他内容的一致性，从而提高效率。

- 使用脚本可以有效地引导项目的启动过程，并确保所需组件的下载和提取。这种便利性使得开发者可以专注于更重要的编码任务，而不是配置环境。
- 宪法文件的引入为项目设定了非谈判的原则。这种文件帮助开发者确保项目遵循特定的标准，例如始终进行测试和使用特定版本的库。
- 在 VS Code 中使用自定义的斜杠命令可以有效地提高工作效率。这些命令为开发者提供了一组明确的指令，确保遵循特定的开发约定，减少错误。

12:08 在视频中，讨论了使用GPD5模型进行开发的优缺点。通过实验和反馈，开发者可以找到最佳的工作流程和工具，以改进产品并确保满足用户需求。

- GPD5模型在处理内容和模板时，比其他工具更为谨慎和有效。它能够自动填充所需的内容，从而节省开发时间，避免手动输入的繁琐。
- 强调了反馈的重要性，特别是在实验阶段。开发团队欢迎用户的反馈，以便识别问题和改进产品，确保在生产环境中能够运作良好。
- 开发过程中关注简洁性和可访问性是重要的原则。尽管当前处于原型阶段，但在生产环境中，性能和安全性是必须优先考虑的。

18:10 这个视频介绍了如何在开发过程中使用规范模板和自动化脚本来管理项目。通过使用Git分支和PowerShell脚本，开发者可以组织工作，避免对生产环境造成影响，并且可以轻松回滚不满意的更改。

- 规范模板在项目开发过程中提供了一个重要的基准，使得开发者能够在实验时不干扰现有的实施。这种方法不仅帮助团队清晰地组织工作，还确保了项目的可控性和可追溯性。
- 视频中强调了接受检查表的重要性，确保每个规范都有明确的确认步骤。开发者应当在编写规范时，确保没有遗漏任何需要澄清的内容，以维护项目的质量。
- 开发者在使用LLM生成的内容时，仍需进行仔细审查和必要的手动调整。虽然LLM可以提供帮助，但最终的决策和具体要求仍需由人来确认，以满足项目的特殊需求。

24:14 在构建静态网站时，确保其响应式设计和移动友好性是至关重要的。随着移动设备使用的增加，开发者需要考虑如何满足未来的需求，以便提供更好的用户体验。

- 在项目启动过程中，使用计划提示和辅助脚本可以有效地帮助组织项目结构。开发者可以通过终端执行命令，自动生成必要的配置文件和元数据，从而简化部署流程。
- 在项目中遵循不容谈判的原则是确保开发质量的关键。通过使用合同和规范，开发者可以确保项目始终符合预设的技术要求和标准，从而减少潜在问题。
- 对于未来的功能扩展，开发者可以利用现有的项目结构快速添加新特性。例如，通过简单的命令生成新的子文件夹和配置，可以轻松实现功能的迭代和修改。

30:16 本视频讲述了如何有效地使用任务管理工具来实现一个播客网站的开发。通过分解任务并采用测试驱动开发的方法，确保每个步骤都能顺利进行，从而提高开发效率。

- 在项目开发初期，建立一个详细的数据模型和规范是非常重要的。这不仅为团队提供了清晰的方向，还确保了项目的各个部分能够紧密结合，避免了开发过程中的混乱。
- 采用任务管理工具可以将复杂的开发过程拆分为更易管理的任务。通过这种方式，开发人员可以逐步解决每个问题，确保每个功能模块都能有效实现。
- 测试驱动开发（TDD）是一种有效的开发策略，强调在实现功能之前先编写测试用例。这种方法不仅可以提高代码质量，还能在开发过程中及时发现并解决问题。

36:28 通过使用规范驱动开发，创建和自定义一个播客网站变得更加高效。利用这种方法，可以轻松地根据设计要求进行调整和功能增加，从而提高软件的一致性和可维护性。

- 在构建播客网站时，使用npm命令如npm run build和npm run dev可以有效地查看网站效果。这一过程确保了网站各个页面的呈现符合预期，并提供了良好的用户体验。
- 通过将设计工具（如Figma）与开发相结合，可以确保网站在实现时符合组织的设计系统。这种方法减少了随意构建的可能性，确保最终产品更具一致性。
- 在开发过程中，拥有清晰的规范和实现文档使得后续的优化和功能扩展变得更加简单。随着对上下文的理解加深，团队可以更高效地构建一致的软件解决方案。